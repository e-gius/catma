/* (This is the new BSD license.)
* Copyright (c) 2012, Chris Culy
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Chris Culy nor the 
*		names of its contributors may be used to endorse or promote 
*		products from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Chris Culy
* ``AS IS'' AND ANY OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
* ARE DISCLAIMED. IN NO EVENT SHALL Chris Culy
* BE LIABLE FOR ANY, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
* CONSEQUENTIAL DAMAGES INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
* GOODS OR SERVICES; OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
* CAUSED AND ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
* TORT INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/"use strict";

var doubletree = doubletree || {};

(function() {
  doubletree.Trie = function(caseSensitive, fldNames, fldDelim, distinguishingFldsArray) {
    function TrieNode(item, id, count) {
      this.id = id;
      this.count = count;
      this.info = {
        count: count,
        ids: {}
      };
      if (item == null) {
        this.item = rootName;
      } else {
        this.item = item;
        this.info.ids = {};
        this.info.ids[id] = true;
        var flds = item.split(fieldDelim);
        for (var i in flds) {
          this.info[fieldNames[i]] = [ flds[i] ];
        }
      }
      this.nodes = {};
      this.addNgram = function(itemArray, id, count) {
        if (!count) {
          count = 1;
        }
        var thisItem, thisKey;
        if (itemArray.length > 0) {
          thisItem = itemArray.shift();
          var theseFlds = thisItem.split(fieldDelim);
          thisKey = theseFlds.filter(function(f, i) {
            return distinguishingFieldsArray.indexOf(fieldNames[i]) > -1;
          }).map(function(f) {
            if (noCase) {
              return f.toLocaleLowerCase();
            }
            return f;
          }).join(fieldDelim);
        } else {
          thisItem = endNG;
          thisKey = thisItem;
        }
        var subTrie;
        if (thisKey in this.nodes && this.nodes[thisKey] instanceof TrieNode) {
          subTrie = this.nodes[thisKey];
          subTrie.info.count += count;
          subTrie.info.ids[id] = true;
          for (var f in theseFlds) {
            var thisFld = theseFlds[f];
            if (subTrie.info[fieldNames[f]].indexOf(thisFld) == -1) {
              subTrie.info[fieldNames[f]].push(thisFld);
            }
          }
        } else {
          subTrie = new TrieNode(thisItem, id, count);
          this.nodes[thisKey] = subTrie;
        }
        if (thisItem != endNG) {
          subTrie.addNgram(itemArray, id, count);
        }
      };
      this.getUniqRoot = function() {
        if (this.item == rootName) {
          var children = Object.keys(this.nodes);
          if (children.length == 1) {
            return this.nodes[children[0]];
          }
        }
        return this;
      };
      this.toTree = function(filterFuns, descendentLevel) {
        if (!descendentLevel) {
          descendentLevel = 0;
        }
        if (!filterFuns) {
          filterFuns = [];
        }
        var what = {
          children: []
        };
        what.name = this.item;
        what.info = this.info;
        what.pruned = {};
        for (var item in this.nodes) {
          var itemNode = this.nodes[item];
          var thisFilter = filterFuns[descendentLevel];
          if (!thisFilter || thisFilter && thisFilter(itemNode.info)) {
            what.children.push(itemNode.toTree(filterFuns, descendentLevel + 1));
            if (itemNode.pruned != {}) {
              addTo(what.pruned, itemNode.pruned);
            }
          } else {
            addTo(what.pruned, itemNode.info.ids);
          }
        }
        what.info.continuations = what.children.length;
        if (what.children.length == 0) {
          what.children = null;
          what.maxChildren = 0;
          if (what.name) {
            what.maxLen = what.name.length;
          } else {
            what.maxLen = 0;
          }
          what.minCount = what.info.count;
        } else {
          var cMax = d3.max(what.children.map(function(c) {
            return c.maxChildren;
          }));
          what.maxChildren = Math.max(what.children.length, cMax);
          var maxLen = d3.max(what.children.map(function(c) {
            return c.maxLen;
          }));
          what.maxLen = Math.max(maxLen, what.name.length);
          what.minCount = d3.min(what.children.map(function(c) {
            return c.minCount;
          }));
        }
        return what;
      };
    }
    function addTo(o1, o2) {
      for (var k in o2) {
        o1[k] = o2[k];
      }
    }
    var endNG = " ";
    var rootName = "_root_";
    var noCase = !caseSensitive && true;
    if (!fldNames) {
      fldNames = [ "item" ];
    }
    var fieldNames = fldNames;
    if (!fieldDelim) {
      fieldDelim = "	";
    }
    var fieldDelim = fldDelim;
    if (!distinguishingFieldsArray) {
      distinguishingFieldsArray = [ fieldNames[0] ];
    }
    var distinguishingFieldsArray = distinguishingFldsArray;
    var trie = new TrieNode(rootName, -1, 0);
    this.addNgram = function(itemArray, id, count) {
      trie.addNgram(itemArray, id, count);
    };
    this.getUniqRoot = function() {
      var what = new doubletree.Trie(!noCase, fieldNames, fieldDelim, distinguishingFieldsArray);
      what.trie(trie.getUniqRoot());
      return what;
    };
    this.toTree = function(filterFuns, descendentLevel) {
      return trie.toTree(filterFuns, descendentLevel);
    };
    this.serialize = function() {
      return JSON.stringify(this);
    };
    this.deserialize = function(serialized) {
      var obj = JSON.parse(serialized);
      endNG = obj.endNG();
      rootName = obj.rootName();
      noCase = obj.caseSensitive();
      fieldNames = obj.fieldNames();
      fieldDelim = obj.fieldDelim();
      distinguishingFieldsArray = obj.distinguishingFieldsArray();
      trie = obj.trie();
    };
    this.endNG = function() {
      return endNG;
    };
    this.rootName = function() {
      return rootName;
    };
    this.trie = function(value) {
      if (arguments.length > 0) {
        trie = value;
      }
      return trie;
    };
    this.caseSensitive = function() {
      return !noCase;
    };
    this.fieldNames = function() {
      return fieldNames;
    };
    this.fieldDelim = function() {
      return fieldDelim;
    };
    this.distinguishingFieldsArray = function() {
      return distinguishingFieldsArray;
    };
  };
})();